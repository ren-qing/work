[参考网站](https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/r8ytog/)

# 复杂度

## 时间复杂度

体现算法运行使用的时间随「数据大小 *N* 」而增大的速度。

根据定义，时间复杂度指输入数据大小为 N*N* 时，算法运行所需花费的时间。

统计的是算法的「计算操作数量」，而不是「运行的绝对时间」。

算法运行时间受到「编程语言 、计算机处理器速度、运行环境」等多种因素影响。

###### 根据输入数据的特点，时间复杂度具有**「最差」、「平均」、「最佳」**三种情况，分别使用 ***O* , Θ , Ω** 三种符号表示。

**大 *O*** 是最常使用的时间复杂度评价渐进符号

*O*(1)<*O*(log*N*)<*O*(*N*)<*O*(*N*log*N*)<*O*(*N*^2)<*O*(2^*N*)<*O*(*N*!)

二分法、分治策略  **|** 一重循环 **|**  双重循环内有一个是分治的排序算法 **|** 二重循环 **|** 递归  | 递归循环

<img src="https://pic.leetcode-cn.com/1623519242-UTNefQ-Picture1.png" alt="Picture1.png" style="zoom: 33%;" />

## 空间复杂度

体现算法运行使用的空间随「数据大小 *N* 」而增大的速度。

输入空间： 存储输入数据所需的空间大小；
暂存空间： 算法运行过程中，存储所有中间变量和对象等数据所需的空间大小；
输出空间： 算法运行返回时，存储输出数据所需的空间大小；

通常情况下，空间复杂度指在输入数据大小为 N*N* 时，算法运行所使用的「暂存空间」+「输出空间」的总体大小。

- 指令空间
  - 编译后，程序指令所使用的内存空间。
- 数据空间
  - 算法中的各项变量使用的空间，包括：声明的常量、变量、动态数组、动态对象等使用的内存空间。
- 栈帧空间
  - 算法中，栈帧空间的累计常出现于递归调用。

空间复杂度统计算法在 “最差情况” 下使用的空间大小，以体现算法运行所需预留的空间量，使用符号 O*O* 表示。

最差情况有两层含义，分别为「最差输入数据」、算法运行中的「最差运行点」。

*O*(1)<*O*(log*N*)<*O*(*N*)<*O*(*N*2)<*O*(2*N*)



# 算法分类

| 动态规划 | 回溯算法 | 查找算法 | 搜索算法 | 贪心算法 | 分治算法 | 位运算 | 双指针 | 排序 | 模拟 | 数学 |
| :------: | :------: | :------: | :------: | :------: | :------: | :----: | :----: | :--: | :--: | ---- |
|          |          |          |          |          |          |        |        |      |      |      |

# 数据结构分类

| 数组 | 字符串 | 栈 / 队列 | 链表 |  树  |  图  |  堆  | 哈希表 |
| :--: | :----: | :-------: | :--: | :--: | :--: | :--: | :----: |
|      |        |           |      |      |      |      |        |

<img src="https://pic.leetcode-cn.com/1599638810-SZDwfK-Picture1.png" alt="Picture1.png" style="zoom: 33%;" />



## 数组

### 普通数组

数组是将相同类型的元素存储于连续内存空间的数据结构，其长度不可变。

```java
//创建数组 声明、初始化
int[] array = new int[5];
//赋值
array[0] = 0;

//或者
int[] array2 = {0,1,2,3,4};
```

### 可变数组

「可变数组」是经常使用的数据结构，其基于数组和扩容机制实现，相比普通数组更加灵活。常用操作有：访问元素、添加元素、删除元素。

```java
List<Integer> array = new ArrayList<>();
//向尾部添加元素
array.add(2);
```

## 链表

链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是非连续的。链表的节点对象具有两个成员变量：「值 `val`」，「后继节点引用 `next`」 。

```java
class ListNode {
	int val;  //节点值
    ListNode next; //后继节点引用
    ListNode(int x){ val = x ;}
}

//实例化节点
ListNode n1 = new ListNode(4);
ListNode n2 = new ListNode(4);
//构建引用指向
n1.next = n2;

```

## 栈

栈是一种具有 「先入后出」 特点的抽象数据结构，可使用数组或链表实现。

```java
Stack<Integer> stack = new Stack<>();
stack.push(1);
stack.push(2);
stack.pop();  //出栈元素为2
```

**通常情况下，不推荐使用 Java 的 `Vector` 以及其子类 `Stack` ，而一般将 `LinkedList` 作为栈来使用。**

[参考博客](https://blog.csdn.net/cartoon_/article/details/87992743)

```java
LinkedList<Integer> stack = new LinkedList<>();
stack.addLast(1);
stack.addLast(2);
stack.removeLast();   //出栈2
```

## 队列

队列是一种具有 「先入先出」 特点的抽象数据结构，可使用链表实现。

```java
Queue<Integer> queue = new LinkedList<>();
queue.offer(1);
queue.offer(2);
queue.poll();//出队元素为2
```

## 树

树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 root」。以二叉树为例，每个节点包含三个成员变量：「值 val」、「左子节点 left」、「右子节点 right」 。

```java
class TreeNode {
	int val;
    TreeNode left;
 	TreeNode right;   
    TreeNode(int x) {val = x;}
}
//初始化节点
TreeNode n1 = new TreeNode(1);
TreeNode n2 = new TreeNode(1);
TreeNode n3 = new TreeNode(1);
TreeNode n4 = new TreeNode(1);
//构造引用指向
n1.left = n2;
n1.right = n3;
n2.left = n4;

```

## 图

图是一种非线性数据结构，由「节点（顶点）`vertex`」和「边 `edge`」组成，每条边连接一对顶点。根据边的方向有无，图可分为「有向图」和「无向图」。

<img src="https://pic.leetcode-cn.com/1599579136-Fxseew-Picture7.png" alt="Picture7.png" style="zoom:50%;" />

### 图的表示方法

#### 邻接矩阵

```java
int[] vertices = {1, 2, 3, 4, 5};
int[][] edges = {{0, 1, 1, 1, 1},
                 {1, 0, 0, 1, 0},
                 {1, 0, 0, 0, 1},
                 {1, 1, 0, 0, 1},
                 {1, 0, 1, 1, 0}};
```



#### 邻接表

使用数组 verticesvertices 存储顶点，邻接表 edgesedges 存储边。 edgesedges 为一个二维容器，第一维 ii 代表顶点索引，第二维 edges[i]edges[i] 存储此顶点对应的边集和；例如 edges[0] = [1, 2, 3, 4]edges[0]=[1,2,3,4] 代表 vertices[0]vertices[0] 的边集合为 [1, 2, 3, 4][1,2,3,4] 。

```java
int[] vertices = {1, 2, 3, 4, 5};
List<List<Integer>> edges = new ArrayList<>();

List<Integer> edge_1 = new ArrayList<>(Arrays.asList(1, 2, 3, 4));
List<Integer> edge_2 = new ArrayList<>(Arrays.asList(0, 3));
List<Integer> edge_3 = new ArrayList<>(Arrays.asList(0, 4));
List<Integer> edge_4 = new ArrayList<>(Arrays.asList(0, 1, 4));
List<Integer> edge_5 = new ArrayList<>(Arrays.asList(0, 2, 3));
edges.add(edge_1);
edges.add(edge_2);
edges.add(edge_3);
edges.add(edge_4);
edges.add(edge_5);
```

邻接矩阵的大小只与节点数量有关，即 N^2 ，其中 N 为节点数量。因此，当边数量明显少于节点数量时，使用邻接矩阵存储图会造成较大的内存浪费。因此，邻接表 适合存储稀疏图（顶点较多、边较少）； 邻接矩阵 适合存储稠密图（顶点较少、边较多）。

## 散列表

散列表（哈希表）是一种非线性数据结构，通过利用 Hash 函数将指定的「键 `key`」映射至对应的「值 `value`」，以实现高效的元素查找。

```java
// 初始化散列表
Map<String, Integer> dic = new HashMap<>();

// 添加 key -> value 键值对
dic.put("小力", 10001);
dic.put("小特", 10002);
dic.put("小扣", 10003);

// 从姓名查找学号
dic.get("小力"); // -> 10001
dic.get("小特"); // -> 10002
dic.get("小扣"); // -> 10003
```

<img src="https://pic.leetcode-cn.com/1599811794-ruXMOV-Picture8.png" alt="Picture8.png" style="zoom: 33%;" />

[上次阅读](https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/50e446/)
